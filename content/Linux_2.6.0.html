title=Linux 2.6.0
date=2003-12-19 10:02:10.689
type=post
status=published
tags=Linux
~~~~~~
<p>I'm sure you've read slashdot before here, so this is redundant, but it seems that the <a href = "http://www.kernel.org/">Linux 2.6.0</a> kernel source has been released.  It's been a while since I've looked at the pre-kernels, but I can't buy that it's ready for prime time.  I'll be building it shortly and testing it on my laptop (an old Dell Inspiron 3800).</p>
<p>Hooray for no longer having to build alsa seperately.  Debian's <code>kernel-package</code> tool made it not quite as painful, though.  I don't look forward to trying to get the mach64 drm stuff working again though.  That's always taken some patching to get built against 2.6 kernels.  I may justn run without it for a bit to test stability.  I've suspected mach64 for my past 2.4 troubles in X.</p>
<p><b>Update:</b> Everything seems to be working well enough.  Sound scheduling has much improved (become usable) from the -test5 days.  Since I was using the 2.4-ck patches before, I already saw some of the advantages of the new schedulers and a preemptive kernel, so performance of 2.6 doesn't feel all that more amazing.</p>
<p>IRDA isn't loading right now, so I'll have to look at that later.  It's probably just a matter of changed module names.</p>
<p><b>2003-12-19 08:52</b>:  I found the <code>/proc/sleep</code> file into which I can <code>echo 4</code> and have the machine suspend itself to it's swap partitions!  It's faster than doing a BIOS suspend-to-disk, since it doesn't blindly copy 384M of RAM to a partition.  This isn't only useful for the laptop.  I'm going to use this on the server.  I'll never have to sacrifice my uptime again due to power outages.  Instead of shutting down  when the UPS gets low, I'll suspend it and resume it when the power returns!  MuahaahAAAA!</p>
<p>Also, IRDA is working by loading the <code>irtty_sir</code> module at boot and then letting <code>/etc/init.d/irda</code> (which calls <code>irattach</code>).</p>
<p>This kernel seems to represent threads differently as well.  It used to be that each thread within a process got its own pid and it was listed by <code>ps</code>.  Now I only see <i>one</i> <code>java</code> process for my JBoss server instead of 25 or so.  Within its /proc/pid structure though, there's a directory called <i>tasks</i> which has a whole collection of other PIDs.  They are grouped now, which makes process viewing a bit cleaner.</p>
<p><b>2003-12-19 09:53</b>: I switched to ACPI and loaded up every last module acpi-related module.  Button events work, so the power button kicks off an <code>init 0</code> and shutsdown properly.  Other buttons like the LID report properly.  Gnome's battery meter understands ACPI, so it displays, but the battery info seems a bit skittish and may not like swapping batteries.  Loading ACPI also caused the <code>/proc/sleep</code> hook to move to <code>/proc/acpi/sleep</code>.  I'm also finding that I need to develop a big long suspend script which unloads/saves some things trigger suspend, then reload everything (since it continues running after resume).  This so far includes the <code>psmouse</code> module, cardctl eject/insert, and hwclock.</p>
